#!/usr/bin/env bash
# CyberPower PDU Bridge
# Created by Matthew Valancy, Valpatel Software LLC
# Copyright 2026 GPL-3.0 License
# https://github.com/mvalancy/CyberPower-PDU
set -euo pipefail

cd "$(dirname "$0")"
source lib/common.sh

check_help "${1:-}" "./test" "Run tests against the PDU bridge" \
"Usage: ./test [mode]

Modes:
  --unit      Run pytest unit tests with branded HTML report (default)
  --real      Test against a real PDU via SNMP
  --mock      Start the stack in mock mode and run integration tests
  --hardware  Run live hardware validation suite (needs PDU_HOST)
  --snmpwalk  Full OID discovery walk against the PDU (saves to file)
              Walks ePDU, ePDU2, and standard MIB-II trees
  --e2e       Run Playwright browser E2E tests against running bridge
  --e2e-mock  Auto-start bridge in mock mode, run all non-hardware E2E tests
  --e2e-hw    Run Playwright hardware E2E tests (needs HW_TEST=true)

Examples:
  ./test                              Run unit tests
  ./test --hardware                   Run hardware validation (PDU_HOST in .env)
  PDU_HOST=192.168.20.177 ./test --real  Test against a specific PDU
  ./test --e2e-mock                   Run browser tests with mock data"

setup_log "test"
banner

source .env 2>/dev/null || true

MODE="${1:---unit}"
PASS=0
FAIL=0

# Ensure reports directory exists
mkdir -p reports

pass() { success "$1"; ((PASS++)); }
fail() { error "$1"; ((FAIL++)); }

summary() {
    echo ""
    if [ "$FAIL" -eq 0 ]; then
        step "Results: $PASS passed, $FAIL failed"
    else
        error "Results: $PASS passed, $FAIL failed"
    fi
    echo ""
    success "Log saved to $LOG_FILE"
    [ "$FAIL" -eq 0 ] && exit 0 || exit 1
}

case "$MODE" in
    --unit)
        step "Running pytest unit tests"
        pytest tests/ -v \
            --ignore=tests/test_reliability.py \
            --ignore=tests/test_hardware_validation.py \
            --html=reports/test-report.html \
            --css=tests/report.css \
            --self-contained-html \
            2>&1 || true
        echo ""
        if [ -f reports/test-report.html ]; then
            success "Report: reports/test-report.html"
        fi
        success "Log saved to $LOG_FILE"
        exit 0
        ;;

    --hardware)
        step "Running hardware validation suite"
        if [ -z "${PDU_HOST:-}" ]; then
            error "PDU_HOST not set. Set it in .env or pass as env var."
            info "  PDU_HOST=192.168.x.x ./test --hardware"
            exit 1
        fi
        pytest tests/test_hardware_validation.py -v \
            --html=reports/hardware-validation.html \
            --css=tests/report.css \
            --self-contained-html \
            2>&1 || true
        echo ""
        if [ -f reports/hardware-validation.html ]; then
            success "Report: reports/hardware-validation.html"
        fi
        success "Log saved to $LOG_FILE"
        exit 0
        ;;

    --snmpwalk)
        step "SNMP Walk against ${PDU_HOST:-192.168.20.177}"
        HOST="${PDU_HOST:-192.168.20.177}"
        COMMUNITY="${PDU_COMMUNITY_READ:-public}"
        OUTFILE="snmpwalk-$(date +%Y%m%d-%H%M%S).txt"

        if ! command -v snmpwalk &>/dev/null; then
            error "snmpwalk not installed. Run ./bootstrap to install snmp tools."
            exit 1
        fi

        # ePDU MIB — identity, banks, outlets, ATS, input
        step "Walking ePDU MIB (1.3.6.1.4.1.3808.1.1.3)"
        snmpwalk -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.4.1.3808.1.1.3 2>/dev/null | tee "$OUTFILE"

        # ePDU2 MIB — source status, extended data
        step "Walking ePDU2 MIB (1.3.6.1.4.1.3808.1.1.6)"
        snmpwalk -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.4.1.3808.1.1.6 2>/dev/null | tee -a "$OUTFILE"

        # Standard MIB-II system info
        step "Walking MIB-II system (1.3.6.1.2.1.1)"
        snmpwalk -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.2.1.1 2>/dev/null | tee -a "$OUTFILE"

        # Interfaces (may expose MAC address)
        step "Walking MIB-II interfaces (1.3.6.1.2.1.2)"
        snmpwalk -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.2.1.2 2>/dev/null | tee -a "$OUTFILE"

        # IP addressing
        step "Walking MIB-II IP (1.3.6.1.2.1.4.20)"
        snmpwalk -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.2.1.4.20 2>/dev/null | tee -a "$OUTFILE"

        echo ""
        success "Saved to $OUTFILE ($(wc -l < "$OUTFILE") lines)"
        success "Log saved to $LOG_FILE"
        ;;

    --e2e)
        step "Running Playwright E2E tests (against running bridge)"
        cd tests/e2e
        if [ ! -d node_modules ]; then
            info "Installing Playwright..."
            npm install && npx playwright install chromium --with-deps
        fi
        NO_AUTO_SERVER=true BASE_URL="${BASE_URL:-http://localhost:8080}" \
            npx playwright test --grep-invert @hardware
        exit $?
        ;;

    --e2e-mock)
        step "Running Playwright E2E tests (auto-start mock bridge)"
        cd tests/e2e
        if [ ! -d node_modules ]; then
            info "Installing Playwright..."
            npm install && npx playwright install chromium --with-deps
        fi
        npx playwright test --grep-invert @hardware
        exit $?
        ;;

    --e2e-hw)
        step "Running Playwright hardware E2E tests"
        cd tests/e2e
        if [ ! -d node_modules ]; then
            info "Installing Playwright..."
            npm install && npx playwright install chromium --with-deps
        fi
        HW_TEST=true NO_AUTO_SERVER=true BASE_URL="${BASE_URL:-http://localhost:8080}" \
            npx playwright test hardware.spec.ts hardware-live.spec.ts
        exit $?
        ;;

    --mock)
        step "Mock Integration Test"

        # Start stack in mock mode
        export BRIDGE_MOCK_MODE=true
        docker compose up -d --build
        sleep 5

        info "Checking services..."
        docker compose ps --format '{{.Name}} {{.Status}}' | while read -r line; do
            info "  $line"
        done

        # Check MQTT messages are flowing
        echo ""
        step "Checking MQTT data flow"
        MSGS=$(timeout 5 mosquitto_sub -h localhost -t 'pdu/#' -C 5 -v 2>/dev/null || true)
        if [ -n "$MSGS" ]; then
            pass "MQTT messages flowing"
            echo "$MSGS" | head -5 | sed 's/^/    /'
        else
            fail "No MQTT messages received"
        fi

        # Check bridge status
        STATUS=$(timeout 3 mosquitto_sub -h localhost -t 'pdu/+/bridge/status' -C 1 2>/dev/null || true)
        if [ "$STATUS" = "online" ]; then
            pass "Bridge status: online"
        else
            fail "Bridge status: '$STATUS'"
        fi

        # Check outlet state published
        STATE=$(timeout 3 mosquitto_sub -h localhost -t 'pdu/+/outlet/1/state' -C 1 2>/dev/null || true)
        if [ "$STATE" = "on" ] || [ "$STATE" = "off" ]; then
            pass "Outlet 1 state: $STATE"
        else
            fail "Outlet 1 state not found: '$STATE'"
        fi

        # Test outlet command
        echo ""
        step "Testing outlet command"
        mosquitto_pub -h localhost -t "pdu/${PDU_DEVICE_ID:-pdu44001}/outlet/1/command" -m "off"
        sleep 2
        RESP=$(timeout 3 mosquitto_sub -h localhost -t "pdu/+/outlet/1/command/response" -C 1 2>/dev/null || true)
        if echo "$RESP" | grep -q '"success"'; then
            pass "Command response received"
        else
            fail "No command response: '$RESP'"
        fi

        # Check InfluxDB has data (give telegraf time)
        sleep 5
        INFLUX_RESULT=$(docker compose exec influxdb influx query \
            --org "${INFLUXDB_ORG:-cyber-pdu}" \
            --token "${INFLUXDB_ADMIN_TOKEN:-cyber-pdu-admin-token}" \
            'from(bucket: "pdu") |> range(start: -1m) |> limit(n: 1)' 2>/dev/null || true)
        if [ -n "$INFLUX_RESULT" ]; then
            pass "InfluxDB has data"
        else
            fail "No data in InfluxDB (may need more time)"
        fi

        summary
        ;;

    --real|"")
        step "Real PDU Test against ${PDU_HOST:-192.168.20.177}"
        HOST="${PDU_HOST:-192.168.20.177}"
        COMMUNITY="${PDU_COMMUNITY_READ:-public}"

        # SNMP connectivity
        step "SNMP connectivity"
        if command -v snmpget &>/dev/null; then
            RESULT=$(snmpget -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.4.1.3808.1.1.3.1.1.0 2>/dev/null || true)
            if [ -n "$RESULT" ]; then
                pass "SNMP reachable: $RESULT"
            else
                fail "SNMP not reachable at $HOST"
            fi

            # Read outlet count
            OC=$(snmpget -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.4.1.3808.1.1.3.1.8.0 2>/dev/null || true)
            if [ -n "$OC" ]; then
                pass "Outlet count: $OC"
            else
                fail "Cannot read outlet count"
            fi

            # Read input voltage
            IV=$(snmpget -v2c -c "$COMMUNITY" "$HOST" 1.3.6.1.4.1.3808.1.1.3.5.7.0 2>/dev/null || true)
            if [ -n "$IV" ]; then
                pass "Input voltage: $IV"
            else
                fail "Cannot read input voltage"
            fi
        else
            warn "snmpget not installed — run ./bootstrap to install snmp tools"
        fi

        # Check if stack is running
        echo ""
        step "Stack check"
        if docker compose ps --format '{{.Name}}' 2>/dev/null | grep -q mosquitto; then
            pass "Docker stack is running"

            # MQTT check
            MSGS=$(timeout 5 mosquitto_sub -h localhost -t 'pdu/#' -C 3 -v 2>/dev/null || true)
            if [ -n "$MSGS" ]; then
                pass "MQTT data flowing"
                echo "$MSGS" | head -3 | sed 's/^/    /'
            else
                fail "No MQTT messages (is bridge running?)"
            fi
        else
            warn "Stack not running. Start with: ./start"
        fi

        summary
        ;;

    *)
        error "Unknown mode: $MODE"
        info "Run ./test --help for usage"
        exit 1
        ;;
esac
